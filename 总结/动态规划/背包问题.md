作为「 背包问题」，它的特点是：「每个数只能用一次」。解决的基本思路是：**物品一个一个选，容量也一点一点增加去考虑**，这一点是「动态规划」的思想，特别重要。在实际生活中，我们也是这样做的，一个一个地尝试把候选物品放入「背包」，通过比较得出一个物品要不要拿走。

# 0-1 背包问题

0-1背包问题是指每一种物品都只有一件，可以选择放或者不放。现在假设有n件物品，背包承重为m。

对于这种问题，我们可以采用一个二维数组去解决：f\[i][j]，其中 i 代表加入背包的是前 i 件物品，j 表示背包的承重，f\[i][j] 表示当前状态下能放进背包里面的物品的最大总价值。那么，f\[n][m] 就是我们的最终结果了。



#### [416.分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

题目：给定一个**只包含正整数**的**非空**数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

直接解决的子问题：在数组中任意取出元素， 判断元素和能否为给定值。

状态定义：使用二维数组， dp\[i][j] 表示在数组中从 0 到 i 中任意取值， 元素和能否为 j 。

状态转移：对于某一状态dp\[i][j]， 有两种情况，选择 nums[i] ， 和不选择 nums[i] 。

* 不选择： 不取当前位置的元素， 则状态转移自  `[0, i-1]` 这个子区间内，是否已经有一部分元素，使得它们的和为 `j` ，那么 `dp[i][j]=true;`

* 选择： 取当前位置的元素， 则状态转移自  `[0, i-1]` 这个子区间内，是否已经有一部分元素，使得它们的和为 `j-nums[i]` ，那么 `dp[i][j]=true;`

  状态转移方程: `dp[i][j] = dp[i - 1][j]  ||  dp[i - 1][j - nums[i]];`